<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="utf-8">
  <title>SVG预览</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="预览和标记SVG的工具">
  <style>
    body {
      margin: 0;
    }
    #root {
      display: flex;
    }
    #root>div{
      flex: 1;
    }
    #svg-container {
      overflow: auto;
      display: flex;
      justify-content: center;
      padding: 8px;
    }
    textarea {
      width: calc(100% - 8px);
      margin-right: 8px;
      height: 400px;
      resize: none;
      box-sizing: border-box;
    }
    svg {
      display: block;
      width: 100px;
      height: 100px;
      border: 1px solid black;
    }
    .saved-svg-item {
      cursor: pointer;
      border: 2px solid #ccc;
      padding: 4px;
      border-radius: 4px;
    }
    .saved-svg-item.selected {
      border-color: #007bff;
      background-color: #e7f3ff;
    }
    .saved-svg-item svg {
      height: 100px;
      border: none;
    }
  </style>
</head>
<body>
<div id="root">
  <div>
    <div>
      <button id="svg-bigger">放大</button>
      <button id="svg-smaller">缩小</button>
      <button id="svg-reset">重置</button>
      <button id="svg-fit">适应</button>
      <span id="scale-indicator">缩放: 100%</span>
      <span id="coordinate-display" style="margin-left: 20px; color: #666;">坐标: (0, 0)</span>
    </div>
    <div id="svg-container">
      <svg id="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"></svg>
    </div>
  </div>
  <div>
    <label for="svg-source">SVG 源码:</label>
    <br/>
    <textarea id="svg-source"></textarea>
    <br/>
    <label for="coordinate-log">坐标记录:</label>
    <br/>
    <textarea id="coordinate-log" style="height: 200px;"></textarea>
    <br/>
    <div style="margin: 8px 0;">
      <button id="btn-save">保存</button>
      <button id="btn-update">更新</button>
      <button id="btn-delete">删除</button>
    </div>
    <label>已保存的SVG:</label>
    <div id="saved-svg-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;"></div>
  </div>
</div>
<script>
  const svgContainerEle = document.getElementById('svg-container');
  const textareaEle = document.getElementById('svg-source');
  const buttonSvgBiggerEle = document.getElementById('svg-bigger');
  const buttonSvgSmallerEle = document.getElementById('svg-smaller');
  const buttonSvgResetEle = document.getElementById('svg-reset');
  const buttonSvgFitEle = document.getElementById('svg-fit');
  const scaleIndicatorEle = document.getElementById('scale-indicator');
  const coordinateDisplayEle = document.getElementById('coordinate-display');
  const coordinateLogEle = document.getElementById('coordinate-log');
  textareaEle.value = '<svg id="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">\n\n</svg>';

  // SVG容错处理函数
  function processSvgInput(input) {
    let processed = input.trim();

    // 1. 属性名转换：React JSX -> SVG标准
    const attributeMap = {
      'strokeLinejoin': 'stroke-linejoin',
      'strokeWidth': 'stroke-width',
      'gradientUnits': 'gradient-units',
      'stopColor': 'stop-color',
      'strokeLinecap': 'stroke-linecap',
      'strokeDasharray': 'stroke-dasharray',
      'strokeDashoffset': 'stroke-dashoffset',
      'strokeOpacity': 'stroke-opacity',
      'xlinkHref': 'xlink:href',
      'fontSize': 'font-size',
      'fontWeight': 'font-weight',
      'alignmentBaseline': 'alignment-baseline',
      'dominantBaseline': 'dominant-baseline',
      'textAnchor': 'text-anchor',
    };

    for (const [jsxAttr, svgAttr] of Object.entries(attributeMap)) {
      const regex = new RegExp(`\\b${jsxAttr}\\b`, 'g');
      processed = processed.replace(regex, svgAttr);
    }

    processed = processed.replace(/<SVGText/g, '<text alignment-baseline="central" dominant-baseline="central" text-anchor="middle"');
    processed = processed.replace(/<SVGText\/>/g, '<text/>');

    // 2. 属性值转换：{} -> 空字符串，处理嵌套花括号
    processed = processed.replace(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g, '""');

    // 3. 检查是否被<svg>标签包裹，如果没有则添加
    if (!processed.match(/^\s*<svg\b/i)) {
      processed = `<svg id="svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">\n${processed}\n</svg>`;
    }

    return processed;
  }

  const sourceOnchange = (event) => {
    try {
      const processedSvg = processSvgInput(event.target.value);
      svgContainerEle.innerHTML = processedSvg;
      textareaEle.value = processedSvg;
      // 更新SVG后自动调整尺寸
      requestAnimationFrame(() => {
        setSvgSize(currentScale);
      });
    } catch (e) {
      console.error(e);
    }
  }

  textareaEle.addEventListener('change', sourceOnchange);

  let currentScale = 1;
  const scaleStep = 0.2;
  const minScale = 0.1;
  const maxScale = 5;
  let clickPoints = []; // 存储点击的坐标点

  function updateScaleIndicator() {
    scaleIndicatorEle.textContent = `缩放: ${Math.round(currentScale * 100)}%`;
  }

  // 将屏幕坐标转换为SVG内部坐标
  function screenToSvgCoords(screenX, screenY) {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return { x: 0, y: 0 };

    const rect = svgElement.getBoundingClientRect();
    const viewBox = svgElement.viewBox.baseVal;

    // 计算相对位置（0-1之间）
    const relativeX = (screenX - rect.left) / rect.width;
    const relativeY = (screenY - rect.top) / rect.height;

    // 计算SVG内部坐标，考虑viewBox的起始坐标
    const x = viewBox.x + relativeX * viewBox.width;
    const y = viewBox.y + relativeY * viewBox.height;

    return { x: x, y: y };
  }

  // 更新坐标显示
  function updateCoordinateDisplay(x, y) {
    coordinateDisplayEle.textContent = `坐标: (${x.toFixed(2)}, ${y.toFixed(2)})`;
  }

  // 添加点击坐标到记录
  function addClickPoint(x, y) {
    const xx = x.toFixed(2);
    const yy = y.toFixed(2);
    clickPoints.push({ x: xx, y: yy });
    coordinateLogEle.value = clickPoints.map(point => `${point.x},${point.y}`).join('\n');
    addPointToSvg(xx, yy);
  }

  // 计算圆点的半径和边框宽度
  function calculatePointSize() {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return { r: 2, strokeWidth: 1 };

    const viewBox = svgElement.viewBox.baseVal;
    const rect = svgElement.getBoundingClientRect();

    // 计算SVG的缩放比例
    const scaleX = rect.width / viewBox.width;
    const scaleY = rect.height / viewBox.height;
    const scale = Math.min(scaleX, scaleY); // 使用较小的缩放比例确保圆点不会过大

    // 计算在SVG坐标系中应该设置的半径和边框宽度
    // 目标：实际显示时半径2px，边框宽度1px
    const targetRadius = 2; // 目标半径2px
    const targetStrokeWidth = 1; // 目标边框宽度1px

    const r = targetRadius / scale;
    const strokeWidth = targetStrokeWidth / scale;

    return { r: r, strokeWidth: strokeWidth };
  }

  // 在SVG中添加红色圆点
  function addPointToSvg(x, y) {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return;

    const sizes = calculatePointSize();

    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', sizes.r);
    circle.setAttribute('fill', 'red');
    circle.setAttribute('stroke', 'black');
    circle.setAttribute('stroke-width', sizes.strokeWidth);
    circle.setAttribute('data-mark-point', 'true');

    svgElement.appendChild(circle);
  }

  // 从textarea更新点击点
  function updateClickPointsFromTextarea() {
    const text = coordinateLogEle.value.trim();
    if (!text) {
      clearClickPoints();
      return;
    }

    const lines = text.split('\n');
    const newPoints = [];

    lines.forEach(line => {
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const parts = trimmedLine.split(',');
        if (parts.length === 2) {
          const x = parseFloat(parts[0]);
          const y = parseFloat(parts[1]);
          if (!isNaN(x) && !isNaN(y)) {
            newPoints.push({ x: x, y: y });
          }
        }
      }
    });

    clickPoints = newPoints;
    updateSvgPoints();
  }

  // 更新SVG中的圆点
  function updateSvgPoints() {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return;

    // 清除现有圆点且属性data-mark-point="true"
    const circles = svgElement.querySelectorAll('circle[data-mark-point="true"]');
    circles.forEach(circle => circle.remove());

    // 添加新的圆点
    clickPoints.forEach(point => {
      addPointToSvg(point.x, point.y);
    });
  }

  // 更新所有标记点的大小
  function updateAllMarkPointsSize() {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return;

    const sizes = calculatePointSize();
    const circles = svgElement.querySelectorAll('circle[data-mark-point="true"]');

    circles.forEach(circle => {
      circle.setAttribute('r', sizes.r);
      circle.setAttribute('stroke-width', sizes.strokeWidth);
    });
  }

  // 清除所有点击点
  function clearClickPoints() {
    clickPoints = [];
    coordinateLogEle.value = '';

    // 清除SVG中的圆点
    const svgElement = document.querySelector('#svg-container svg');
    if (svgElement) {
      const circles = svgElement.querySelectorAll('circle');
      circles.forEach(circle => circle.remove());
    }
  }

  function setSvgSize(scale) {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return;
    const viewBox = svgElement.viewBox.baseVal;
    if (!viewBox.width || !viewBox.height) return;

    // 计算新的尺寸，保持viewBox的比例
    const aspectRatio = viewBox.width / viewBox.height;
    const baseSize = viewBox.height;
    const newWidth = baseSize * scale * aspectRatio;
    const newHeight = baseSize * scale;
    svgElement.style.width = newWidth + 'px';
    svgElement.style.height = newHeight + 'px';
    updateScaleIndicator();
  }

  function fitToContainer() {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return;
    const container = svgContainerEle;
    const viewBox = svgElement.viewBox.baseVal;
    if (!viewBox.width || !viewBox.height) return;
    const containerWidth = container.clientWidth - 20;
    const containerHeight = window.innerHeight - 20 - buttonSvgBiggerEle.parentElement.clientHeight;

    const aspectRatio = viewBox.width / viewBox.height;
    const containerAspectRatio = containerWidth / containerHeight;
    let newWidth, newHeight;
    if (aspectRatio > containerAspectRatio) {
      // SVG更宽，以宽度为准
      newWidth = containerWidth;
      newHeight = containerWidth / aspectRatio;
    } else {
      // SVG更高，以高度为准
      newHeight = containerHeight;
      newWidth = containerHeight * aspectRatio;
    }
    svgElement.style.width = newWidth + 'px';
    svgElement.style.height = newHeight + 'px';
    currentScale = newWidth / (viewBox.height * aspectRatio);
    updateScaleIndicator();
  }
  buttonSvgBiggerEle.addEventListener('click', () => {
    currentScale = Math.min(currentScale + scaleStep, maxScale);
    setSvgSize(currentScale);
    updateAllMarkPointsSize();
  });
  buttonSvgSmallerEle.addEventListener('click', () => {
    currentScale = Math.max(currentScale - scaleStep, minScale);
    setSvgSize(currentScale);
    updateAllMarkPointsSize();
  });
  buttonSvgResetEle.addEventListener('click', () => {
    currentScale = 1;
    setSvgSize(currentScale);
    updateAllMarkPointsSize();
  });
  buttonSvgFitEle.addEventListener('click', () => {
    fitToContainer();
    updateAllMarkPointsSize();
  });

  // 添加鼠标移动和点击事件
  svgContainerEle.addEventListener('mousemove', (event) => {
    const coords = screenToSvgCoords(event.clientX, event.clientY);
    updateCoordinateDisplay(coords.x, coords.y);
  });

  svgContainerEle.addEventListener('click', (event) => {
    const coords = screenToSvgCoords(event.clientX, event.clientY);
    addClickPoint(coords.x, coords.y);
  });

  // 监听坐标记录textarea的变化
  coordinateLogEle.addEventListener('change', () => {
    updateClickPointsFromTextarea();
  });

  // 存储功能
  const savedSvgListEle = document.getElementById('saved-svg-list');
  const btnSaveEle = document.getElementById('btn-save');
  const btnUpdateEle = document.getElementById('btn-update');
  const btnDeleteEle = document.getElementById('btn-delete');
  const STORAGE_KEY = 'svgViewer-savedSvgs';
  let selectedSvgId = null;

  // 从localStorage读取保存的SVG
  function loadSavedSvgs() {
    const saved = localStorage.getItem(STORAGE_KEY);
    return saved ? JSON.parse(saved) : [];
  }

  // 保存到localStorage
  function saveToStorage(data) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  // 获取当前SVG源码和标记点
  function getCurrentSvgData() {
    const svgElement = document.querySelector('#svg-container svg');
    if (!svgElement) return null;
    return {
      svgSource: textareaEle.value,
      clickPoints: [...clickPoints],
      createdAt: +new Date(),
      updatedAt: +new Date()
    };
  }

  // 生成预览图的SVG源码（不包含标记点）
  function generatePreviewSvg(svgSource) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgSource, 'image/svg+xml');
    const svg = doc.querySelector('svg');
    if (!svg) return null;
    
    let viewBox = svg.getAttribute('viewBox');
    if (!viewBox) {
      // 如果没有viewBox，尝试从width和height计算
      const width = parseFloat(svg.getAttribute('width')) || 100;
      const height = parseFloat(svg.getAttribute('height')) || 100;
      viewBox = `0 0 ${width} ${height}`;
    }
    
    const parts = viewBox.split(/\s+/).map(Number);
    if (parts.length < 4) return null;
    
    const [, , width, height] = parts;
    if (!width || !height) return null;
    
    const aspectRatio = width / height;
    const previewHeight = 100;
    const previewWidth = previewHeight * aspectRatio;
    
    // 创建预览SVG的副本，设置尺寸
    const previewSvg = svg.cloneNode(true);
    previewSvg.setAttribute('width', previewWidth);
    previewSvg.setAttribute('height', previewHeight);
    
    const serializer = new XMLSerializer();
    return serializer.serializeToString(previewSvg);
  }

  // 渲染预览列表
  function renderSavedSvgs() {
    const savedSvgs = loadSavedSvgs();
    savedSvgListEle.innerHTML = '';
    
    savedSvgs.forEach((item, index) => {
      const previewSvg = generatePreviewSvg(item.svgSource);
      if (!previewSvg) return;
      
      const itemDiv = document.createElement('div');
      itemDiv.className = `saved-svg-item ${selectedSvgId === item.id ? 'selected' : ''}`;
      itemDiv.innerHTML = previewSvg;
      itemDiv.dataset.id = item.id;
      
      itemDiv.addEventListener('click', () => {
        loadSvgData(item);
        selectedSvgId = item.id;
        renderSavedSvgs();
        updateButtonStates();
      });
      
      savedSvgListEle.appendChild(itemDiv);
    });
  }

  // 加载SVG数据到编辑区
  function loadSvgData(item) {
    textareaEle.value = item.svgSource;
    
    // 更新坐标记录
    const logText = item.clickPoints.map(point => 
      `${point.x.toFixed(2)},${point.y.toFixed(2)}`
    ).join('\n');
    coordinateLogEle.value = logText;
    
    // 更新SVG预览和标记点
    clickPoints = item.clickPoints;
    const processedSvg = processSvgInput(item.svgSource);
    svgContainerEle.innerHTML = processedSvg;

    requestAnimationFrame(() => {
      currentScale = 1;
      setSvgSize(currentScale);
      updateSvgPoints();
    });
  }

  // 更新按钮状态
  function updateButtonStates() {
    const hasSelected = selectedSvgId !== null;
    btnUpdateEle.disabled = !hasSelected;
    btnDeleteEle.disabled = !hasSelected;
  }

  // 保存新SVG
  function saveSvg() {
    const data = getCurrentSvgData();
    if (!data) return;
    
    const savedSvgs = loadSavedSvgs();
    const newId = Date.now().toString();
    savedSvgs.push({
      id: newId,
      ...data
    });
    
    saveToStorage(savedSvgs);
    selectedSvgId = newId;
    renderSavedSvgs();
    updateButtonStates();
  }

  // 更新选中的SVG
  function updateSvg() {
    if (!selectedSvgId) return;
    
    const data = getCurrentSvgData();
    if (!data) return;
    
    const savedSvgs = loadSavedSvgs();
    const index = savedSvgs.findIndex(item => item.id === selectedSvgId);
    if (index === -1) return;
    
    savedSvgs[index] = {
      ...savedSvgs[index],
      svgSource: data.svgSource,
      clickPoints: data.clickPoints,
      updatedAt: +new Date()
    };
    
    saveToStorage(savedSvgs);
    renderSavedSvgs();
  }

  // 删除选中的SVG
  function deleteSvg() {
    if (!selectedSvgId) return;
    
    const savedSvgs = loadSavedSvgs();
    const filtered = savedSvgs.filter(item => item.id !== selectedSvgId);
    
    saveToStorage(filtered);
    selectedSvgId = null;
    renderSavedSvgs();
    updateButtonStates();
  }

  // 绑定按钮事件
  btnSaveEle.addEventListener('click', saveSvg);
  btnUpdateEle.addEventListener('click', updateSvg);
  btnDeleteEle.addEventListener('click', deleteSvg);

  // 初始化：渲染已保存的SVG
  renderSavedSvgs();
  updateButtonStates();

</script>
</body>
</html>
